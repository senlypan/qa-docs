# 理解消息中间件与常见问题

![访问统计](https://visitor-badge.glitch.me/badge?page_id=senlypan.qa.11-mq&left_color=blue&right_color=red)

> 作者: 潘深练
>
> 创建: 2022-05-28

## 一、脑图概览

<iframe id="embed_dom" name="embed_dom" frameborder="0" 
    style="display: block;width: 100%;height: 500px;" 
    src="https://www.processon.com/embed/628892f9f346fb4244d0672c"></iframe>


## 二、消息中间件

### 2.1、介绍

在单个系统中，一些业务处理可以顺序依次的进行。而涉及到跨系统（有时候系统内部亦然）的时候，会产生比较复杂数据交互（也可以理解为消息传递）的需求，这些数据的交互传递方式，可以是同步也可以是异步的。

**在异步传递数据的情况下，往往需要一个载体，来临时存储与分发消息。在此基础上，专门针对消息接收、存储、转发而设计与开发出来的专业应用程序，都可以理解为消息队列中间件**。

![](../_media/images/11-mq/mq-history-001.jpg)

### 2.2、基本思想

利用 **高效可靠** 的消息传递机制进行 **异步** 的数据传输（**最终一致性**）。


### 2.3、应用场景

#### 1、系统解耦

- 解耦是消息队列要解决的 **最本质问题**。

- 将不同性质的业务进行隔离切分，提升性能，主附流程分层，按照重要性进行隔离，减少异常影响。

#### 2、异步通信

- 可以用于业务系统内部的异步通信，也可以用于分布式系统信息交互。

- 基于消息队列的异步调用能够显著降低前端业务的响应时间，提高吞吐量。


#### 3、流量削峰

- 间歇性突刺流量分散处理，减少系统压力，提升系统可用性。

- 基于消息队列还能实现削峰填谷，把慢服务分离到后置链路，提升整个业务链路的性能


#### 4、分布式事务一致性

- RocketMQ 提供的事务消息功能可以处理分布式事务一致性（如电商订单场景）。

- 当然，也可以使用分布式事务中间件，例如 Seata 等

#### 5、消息顺序收发

- 这是最基础的功能，先进先出，消息队列必备。


#### 6、延时消息

- 延迟触发的业务场景，如下单后延迟取消未支付订单等。

#### 7、大数据处理

- 日志处理，kafka。


#### 8、分布式缓存同步

- 消费 MySQL 的 binlog 日志进行缓存同步，或者业务变动直接推送到 MQ 消费。


### 2.5、核心保证

#### 1、可靠性

#### 2、幂等性

#### 3、顺序消息

#### 4、延迟消息

- 延迟队列

- 死信队列

#### 5、事务消息


## 三、消息中间件选型

在传统金融机构、银行、政府机构等有一些老系统还在使用 IBM 等厂商提供的商用 MQ 产品。

当前业界比较流行的开源消息中间件包括：

- ActiveMQ
- RabbitMQ
- RocketMQ
- Kafka
- ZeroMQ

其中应用最为广泛的要数 **RabbitMQ、RocketMQ、Kafka** 这三款。

Redis 在某种程度上也可以是实现类似 “Queue” 和 “Pub/Sub” 的机制，严格意义上不算消息中间件。

### 3.1、选取原则

- 首先，产品应该是 **开源** 的。开源意味着如果队列使用中遇到bug，可以很快修改，而不用等待开发者的更新。
- 其次，产品必须是近几年比较 **流行** 的，要有一个活跃的社区。这样遇到问题很快就可以找到解决方法。同时流行也意味着bug较少。流行的产品一般跟周边系统兼容性比较好。
- 最后，作为消息队列，要具备以下几个特性：
    - 1、消息传输的 **可靠性**：保证消息不会丢失。
    - 2、支持 **集群**，包括横向扩展，单点故障都可以解决。
    - 3、**性能** 要好，要能够满足业务的性能需求。

### 3.2、RabbitMQ

RabbitMQ 开始是用在电信业务的可靠通信的，也是少有的几款支持 AMQP 协议的产品之一。

**优点：**

1. 轻量级，快速，部署使用方便
2. 支持灵活的路由配置。RabbitMQ 中，在生产者和队列之间有一个交换器模块。根据配置的路由规则，生产者发送的消息可以发送到不同的队列中。路由规则很灵活，还可以自己实现。
3. RabbitMQ 的客户端支持大多数的编程语言。

**缺点：**

1. 如果有大量消息堆积在队列中，性能会急剧下降
2. RabbitMQ 的性能在 Kafka 和 RocketMQ 中是最差的，每秒处理几万到几十万的消息。如果应用要求高的性能，不要选择RabbitMQ。
3. RabbitMQ 是 Erlang 开发的，功能扩展和二次开发代价很高。


### 3.3、RocketMQ

**优点：**

RocketMQ 是一个开源的消息队列，使用 java 实现。借鉴了 Kafka 的设计并做了很多改进。

RocketMQ 主要用于 **有序，事务，流计算，消息推送，日志流处理，binlog分发** 等场景。经过了历次的双11考验，性能，稳定性可可靠性没的说。

RocketMQ 几乎具备了消息队列应该具备的所有特性和功能。

java 开发，阅读源代码、扩展、二次开发很方便。

对电商领域的响应延迟做了很多优化。在大多数情况下，响应在毫秒级。如果应用很关注响应时间，可以使用RocketMQ。
性能比RabbitMQ高一个数量级，每秒处理几十万的消息。

**缺点：**

跟周边系统的整合和兼容不是很好。（已在陆续优化与支持）


### 3.4、Kafka

Kafka 的可靠性，稳定性和功能特性基本满足大多数的应用场景。

跟周边系统的兼容性是数一数二的，尤其是大数据和流计算领域，几乎所有相关的开源软件都支持 Kafka。

Kafka 高效，可伸缩，消息持久化。支持分区、副本和容错。

Kafka 是 Scala 和 Java 开发的，对 **批处理** 和 **异步处理** 做了大量的设计，因此 Kafka 可以得到非常高的性能。它的异步消息的发送和接收是三个中最好的，但是跟 RocketMQ 拉不开数量级，每秒处理几十万的消息。

如果是异步消息，并且开启了压缩，Kafka 最终可以达到每秒处理 2000w 消息的级别。

**但是由于是异步的和批处理的，延迟也会高，不适合电商场景。**

| 维度                  | RabbitMQ    | RocketMQ                             | Kafka                        |
| ----                  | ----        | ----                                 | ----                         | 
| 单机吞吐量            | 1w 量级      | 10w 量级                             | 10w 量级                      |
| 开发语言              | Erlang       | Java                                 | Java 和 Scala                |
| 消息延迟              | 微秒         | 毫秒                                 | 毫秒                          |
| 消息丢失              | 可能性很低   | 参数优化后可以0丢失                    | 参数优化后可以0丢失           |
| 消费模式              | 推拉         | 推拉                                  | 拉取                         |
| 主题数量对吞吐量的影响 | \            | 几百上千个主题会对吞吐量有一个小的影响  | 几十上百个主题会极大影响吞吐量 |
| 可用性                | 高（主从）   | 很高（主从）                           | 很高（分布式）                |

## 四、JMS 规范

### 4.1、JMS经典模式详解

JMS 即 Java 消息服务（Java Message Service）应用程序接口，是一个 Java 平台中关于面向消息中间件（MOM，Message oriented Middleware）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。与具体平台无关的 API，绝大多数MOM提供商都支持。

它类似于 JDBC(Java Database Connectivity)。

#### 4.1.1、JMS消息

消息是 JMS 中的一种类型对象，由两部分组成：报文头和消息主体。

报文头包括消息头字段和消息头属性。字段是 JMS 协议规定的字段，属性可以由用户按需添加。 

JMS 报文头全部字段：

| 字段名称  | 含义 | 
| ----     | ---- |
| JMSDestination | JMSDestination 字段包含了消息要发送到的目的地。 |
| JMSDeliveryMode | JMSDeliveryMode 字段包含了消息在发送的时候指定的投递模式。 |
| JMSMessageID | 该字段包含了服务器发送的每个消息的唯一标识。 |
| JMSTimestamp | 该字段包含了消息封装完成要发往服务器的时间。不是真正向服务器发送的时间，因为真正的发送时间，可能会由于事务或客户端消息排队而延后。 |
| JMSCorrelationID | 客户端使用该字段的值与另一条消息关联。一个典型的场景是使用该字段，将响应消息与请求消息关联。JMSCorrelationID 可以包含如下值：1、服务器规定的消息ID；2、应用指定的字符串；3、服务器原生的 byte[] 值 |
| JMSReplyTo | 该字段包含了在客户端发送消息的时候指定的Destination。即对该消息的响应应该发送到该字段指定的 Destination 。设置了该字段值的消息一般期望收到一个响应。 |
| JMSRedelivered | 如果这个字段是true，则告知消费者应用这条消息已经发送过了，消费端应用应该小心别重复处理了。 |
| JMSType | 消息发送的时候用于标识该消息的类型。具体有哪些类型，由 JMS 实现厂商决定。 |
| JMSExpiration | 发送消息时，其到期时间将计算为send方法上指定的生存时间值与当前 GMT 值之和。 从send方法返回时，消息的 JMSExpiration 标头字段包含此值。 收到消息后，其JMSExpiration 标头字段包含相同的值。 |
| JMSPriority | JMS 定义了一个十级优先级值，最低优先级为 0，最高优先级为 9。 此外，客户端应将优先级 0-4 视为正常优先级，将优先级 5-9 视为快速优先级。JMS 不需要服务器严格执行消息的优先级排序； 但是，它应该尽力在普通消息之前传递加急消息。 |

消息主体则携带着应用程序的数据或有效负载。

根据有效负载的类型来划分，可以将消息分为几种类型：

1. 简单文本(TextMessage)
2. 可序列化的对象(ObjectMessage)
3. 属性集合(MapMessage)
4. 字节流(BytesMessage)
5. 原始值流(StreamMessage)
6. 无有效负载的消息(Message)。


#### 4.1.2、体系架构

JMS由以下元素组成：

1. JMS供应商产品

JMS 接口的一个实现。该产品可以是 Java 的 JMS 实现，也可以是非 Java 的面向消息中间件的适配器。

2. JMS Client

生产或消费基于消息的 Java 的应用程序或对象。

3. JMS Producer

创建并发送消息的JMS客户。

4. JMS Consumer

接收消息的 JMS 客户。

5. JMS Message

包括可以在 JMS 客户之间传递的数据的对象

6. JMS Queue

缓存消息的容器。消息的接受顺序并不一定要与消息的发送顺序相同。消息被消费后将从队列中移除。

7. JMS Topic

Pub/Sub模式。


#### 4.1.3、对象模型

1. ConnectionFactory 接口（连接工厂）

用户用来创建到 JMS 提供者的连接的被管对象。JMS 客户通过可移植的接口访问连接，这样当下层的实现改变时，代码不需要进行修改。管理员在 JNDI 名字空间中配置连接工厂，这样，JMS 客户才能够查找到它们。根据消息类型的不同，用户将使用队列连接工厂，或者主题连接工厂。

2. Connection 接口（连接）

连接代表了应用程序和消息服务器之间的通信链路。在获得了连接工厂后，就可以创建一个与 JMS 提供者的连接。根据不同的连接类型，连接允许用户创建会话，以发送和接收队列和主题到目标。

3. Destination 接口（目标）

目标是一个包装了消息目标标识符的被管对象，消息目标是指消息发布和接收的地点，或者是队列，或者是主题。JMS 管理员创建这些对象，然后用户通过 JNDI 发现它们。和连接工厂一样，管理员可以创建两种类型的目标，点对点模型的队列，以及发布者/订阅者模型的主题。

4. Session 接口（会话）

表示一个单线程的上下文，用于发送和接收消息。由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。会话的好处是它支持事务。如果用户选择了事务支持，会话上下文将保存一组消息，直到事务被提交才发送这些消息。在提交事务之前，用户可以使用回滚操作取消这些消息。一个会话允许用户创建消息，生产者来发送消息，消费者来接收消息。

5. MessageConsumer 接口（消息消费者）

由会话创建的对象，用于接收发送到目标的消息。消费者可以同步地（阻塞模式），或（非阻塞）接收队列和主题类型的消息。

6. MessageProducer 接口（消息生产者）

由会话创建的对象，用于发送消息到目标。用户可以创建某个目标的发送者，也可以创建一个通用的发送者，在发送消息时指定目标。

7. Message 接口（消息）

是在消费者和生产者之间传送的对象，也就是说从一个应用程序传送到另一个应用程序。一个消息有三个主要部分：


- 消息头（必须）：包含用于识别和为消息寻找路由的操作设置。
- 一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。
- 一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。

![](../_media/images/11-mq/mq-obj-001.png)

#### 4.1.4、模式

Java 消息服务应用程序结构支持两种模式：**点对点也叫队列模式** 和 **发布/订阅模式**。


1. 在点对点或队列模型下

一个生产者向一个特定的队列发布消息，一个消费者从该队列中读取消息。这里，生产者知道消费者的队列，并直接将消息发送到消费者的队列，概括为：

- 一条消息只有一个消费者获得
- 生产者无需在接收者消费该消息期间处于运行状态，接收者也同样无需在消息发送时处于运行状态。
- 每一个成功处理的消息要么自动确认，要么由接收者手动确认。

![](../_media/images/11-mq/mq-model-001.png)

2. 发布/订阅模式

- 支持向一个特定的主题发布消息。
- 0或多个订阅者可能对接收特定消息主题的消息感兴趣。
- 发布者和订阅者彼此不知道对方。
- 多个消费者可以获得消息

在发布者和订阅者之间存在时间依赖性。

- 发布者需要建立一个主题，以便客户能够订阅。
- 订阅者必须保持持续的活动状态以接收消息，否则会丢失未上线时的消息。
- 对于持久订阅，订阅者未连接时发布的消息将在订阅者重连时重发。

![](../_media/images/11-mq/mq-model-002.png)


#### 4.1.5、传递方式

JMS 有两种传递消息的方式。

标记为 NON_PERSISTENT 的消息最多投递一次，而标记为 PERSISTENT 的消息将使用暂存后再转送的机理投递。

如果一个 JMS 服务下线，持久性消息不会丢失，等该服务恢复时再传递。默认的消息传递方式是非持久性的。使用非持久性消息可能降低内务和需要的存储器，当不需要接收所有消息时使用。

#### 4.1.6、供应商

开源软件：

1. Apache ActiveMQ
2. RabbitMQ
3. RocketMQ
4. JBoss 社区所研发的 HornetQ
5. Joram
6. Coridan的MantaRay
7. The OpenJMS Group的OpenJMS

专有的供应商包括：

1. BEA的BEA WebLogic Server JMS
2. TIBCO Software的EMS
3. GigaSpaces Technologies的GigaSpaces
4. Softwired 2006的iBus
5. IONA Technologies的IONA JMS
6. SeeBeyond的IQManager（2005年8月被Sun Microsystems并购）
7. webMethods的JMS+-
8. my-channels的Nirvana
9. Sonic Software的SonicMQ
10. SwiftMQ的SwiftMQ
11. IBM的WebSphere MQ


### 4.2、JMS在应用集群中的问题

生产中应用基本上都是以集群部署的。

在 Queue 模式下，消息的消费没有什么问题，因为不同节点的相同应用会 **抢占式** 地消费消息，这样还能分摊负载。

如果使用 Topic 广播模式？对于一个消息，不同节点的相同应用都会收到该消息，进行相应的操作，这样就 **重复消费** 了。。。

![](../_media/images/11-mq/mq-cluster-queue-001.png)

![](../_media/images/11-mq/mq-cluster-topic-001.png)

> 如何避免重复消费问题？

- 方案一：选择 Queue 模式，创建多个一样的 Queue，每个应用消费自己的 Queue。
    - 弊端：浪费空间，生产者还需要关注下游到底有几个消费者，违反了“解耦”的初衷。

- 方案二：选择 Topic 模式，在业务上做散列，或者通过分布式锁等方式来实现不同节点间的竞争。
    - 弊端：对业务侵入较大，不是优雅的解决方法。

ActiveMQ 通过 “虚拟主题” 解决了这个问题。

生产中似乎需要结合这两种模式：**即不同节点的相同应用间存在竞争，会部分消费（P2P），而不同的应用都需要消费到全量的消息（Topic）模式。这样就可以避免重复消费。**

JMS规范文档(jms-1_1-fr-spec.pdf)下载地址：

[https://download.oracle.com/otndocs/jcp/7195-jms-1.1-fr-spec-oth-JSpec/](https://download.oracle.com/otndocs/jcp/7195-jms-1.1-fr-spec-oth-JSpec/)

JMS 是 J2EE 平台的标准消息传递 API 。它可以在商业和开源实现中使用。每个实现都包括一个 JMS 服务器，一个 JMS 客户端库，以及用于管理消息传递系统的其他特定于实现的组件。 JMS 提供程序可以是消息传递服务的独立实现，也可以是非 JMS 消息传递系统的桥梁。

JMS 客户端 API 是标准化的，因此 JMS 应用程序可在供应商的实现之间移植。但是：

1. 底层消息传递实现未指定，因此 JMS 实现之间没有互操作性。除非存在桥接技术，否则想要共享消息传递的 Java 应用程序必须全部使用相同的JMS实现。

2. 如果没有供应商特定的JMS客户端库来启用互操作性，则非 Java 应用程序将无法访问 JMS。

3. AMQP 0-9-1 是一种消息传递协议，而不是像 JMS 这样的 API 。任何实现该协议的客户端都可以访问支持 AMQP 0-9-1 的代理。

4. 协议级的互操作性允许以任何编程语言编写且在任何操作系统上运行的 AMQP 0-9-1 客户端都可以参与消息传递系统，而无需桥接不兼容的服务器实现。

## 五、AMQP 协议

AMQP 协议文档下载地址：

[https://www.amqp.org/sites/amqp.org/files/amqp0-9-1.zip](https://www.amqp.org/sites/amqp.org/files/amqp0-9-1.zip)

`待补充`

## 六、常见问题

### 6.1、消息中间件如何做生产幂等（考虑成本）？

也就是消除消息的重复消费问题（消费幂等），核心思路是使用 **唯一标识**，来标记某条消息是否已经处理过。

- 唯一标识（考虑存储成本/性能/准确率）
    - 解决方案：
        - **一、基本数据库方案**
            - 1、使用数据库自增主键，或者唯一键来保证数据不会重复变动；
            - 2、使用中间状态，以及状态变动有序性来判断业务是否已经被处理；
            - 3、利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息；
            - 4、或者消息唯一标识，在 Redis 等 NoSQL 中维护一个处理缓存，判断是否已经处理过；
            - 5、如果消费者业务流程比较长，则需要开发者自己保证整个业务消费逻辑中数据处理的事务性。
        - **二、更优数据结构方案**
            - 1、索引树
            - 2、bitmap
            - 3、布隆过滤器
            - 4、布谷鸟过滤器

### 6.2、消息中间件如何保障消息全局有序？

- 全局时钟（根源）
- 一个分区，或多分区生产者打标
- 业务仲裁
- 拓展：研究spanner实现思路

### 6.3、消息中间件有哪些故障模型的存在？

思路：首先要清楚故障模型关系到可靠性，保障可靠性其实就是控制它的故障模型，所以需要枚举出可能造成故障的环节有哪些？然后把他们归一下类，就成故障模型了。

- 人为故障
- 网络故障
- 硬件故障（内存磁盘故障）
- 拜占庭故障
- more

### 6.4、消息中间件做故障转移（解决方案）有几种方法？各有什么优劣？

思路：针对第3点中归类的故障模型，就可以思考解决方案，故障模型和解决方案是1对多的关系，先有故障模型，才有的这些方案。

- 解决【人为故障】靠制度
- 解决【网络故障】靠重试（重试便要思考幂等问题）
- 解决【硬件故障（内存磁盘故障）】靠副本（副本就要考虑持久化问题）/冗余
- 解决【拜占庭故障】可以靠共识算法
- more

延伸理解：**设计系统时**也是一样的思路，先把故障模型列出来，在思考解决方案，解决方案罗列巨细了，**系统可靠性**也就有了基本保障。因为故障模型是可靠性问题的定义。

延伸学习：[《拜占庭将军问题是什么？区块链如何防范恶意节点？-哔哩哔哩】》](https://b23.tv/IiBLmSI)


## 参考

- [《云原生时代消息中间件的演进路线 | 阿里中间件》](https://mp.weixin.qq.com/s/1e-ceBDrNinttYt6HmeMXw)

- [《消息中间件应用的常见问题与方案｜得物技术》](https://mp.weixin.qq.com/s/60V3eoV_jFxBwsK6NiHM-g)

- [《下一代消息平台 Pulsar 到底是什么》](https://juejin.cn/post/6920028494848573448)

- [《架构决策之消息中间件MQ系列六-Pulsar》](https://blog.csdn.net/tcy83/article/details/106731392)



