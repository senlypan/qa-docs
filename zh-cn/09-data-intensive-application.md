# 数据密集型应用

![访问统计](https://visitor-badge.glitch.me/badge?page_id=senlypan.qa.09-data-intensive-application&left_color=blue&right_color=red)

> 作者: 潘深练
>
> 创建: 2022-04-19
>
> 版权声明：自由转载-非商用-非衍生-保持署名（[创意共享3.0许可证](https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh)）


## 一、数据密集型应用

当今许多新型应用都属于数据密集型（data-intensive），而不是计算密集型（compute-intensive）。对于数据密集型应用，CPU 的处理能力往往不是第一限制性因素，关键在于：

- 数据量
- 数据的复杂度
- 数据的快速多变性

数据密集型应用通常也是基于标准模块构建而成，每个模块负责单一的常用功能。例如，许多应用系统都包含以下模块（或称为数据处理系统，data system）：

- 数据库：用以存储数据，这样之后应用可以再次访问
- 高速缓存：缓存那些复杂或操作代价昂贵的结果，以加快下一次访问
- 索引：用户可以按关键字搜索数据并支持各种过滤
- 流式处理：持续发送消息至另一个进程，处理采用异步方式
- 批处理：定期处理大量的累积数据

## 二、认识数据系统

### 1、趋势

我们通常将数据库、队列、高速缓存等视为不同类型的系统。虽然数据库和消息队列存在某些相似性，例如两者都会保存数据（至少一段时间），但他们却有着截然不同的访问模式，这就意味着不同的性能特征和设计实现。

- 首先，近年来出现了许多用于数据存储和处理的新工具。它们针对各种不同的应用场景进行优化，不适合再归为传统类型。例如，Redis 既可以用于数据存储也适用于 **消息队列**，Apache Kafka 作为消息队列也具备了持久化存储保证。系统之间的界限正在变得模糊。
- 其次，越来越多的应用系统需求广泛，单个组件往往无法满足所有数据处理与存储需求。因而需要将任务分解，每个组件负责高效完成的一部分，多个组件依靠应用层代码驱动有机衔接起来。

### 2、问题

设计数据系统或数据服务时，一定会碰到很多棘手的问题。例如：

- 当系统内出现了局部失效时，如何确保数据的正确性与完整性？
- 当发生系统降级（degrade）时，该如何为客户提供一致的良好表现？
- 当负载增加时，系统如何扩展？
- 友好的服务 API 该如何设计？

影响数据系统设计的因素有很多，其中包括相关人员技能和经验水平、遗留系统依赖性、交付周期、对不同风险因素的容忍度、监管合规等。这些因素往往因时因地而异。

一个应用必须完成预期的多种需求，主要包括:
- 功能性需求（即应该做什么，比如各种存储、检索、搜索和处理数据）
- 非功能性需求（即常规性、例如安全性、可靠性、合规性、可伸缩性、兼容性和可维护性）。其中极为重要的 [三个问题](/zh-cn/06-architecture-target?id=二、分布式是架构设计挑战)：
    - 可靠性
    - 扩展性（可伸缩性）
    - 可维护性

## 三、数据模型与查询语言

> 数据模型

数据模型可能是开发软件最重要的部分，它们不仅对软件的编写方式，而且还对如何思考待解决的问题都有深远的影响。

大多数应用程序是通过一层一层 **叠加数据模型** 来构建的。每一层都面临的关键问题是：**如何将其用下一层来表示？**

1）、作为一名应用程序开发人员，观测现实世界（其中包括人员、组织、货物、行为、资金流动、传感器等），通过对象或数据结构，以及操作这些数据结构的 API 来对其建模。这些数据结构往往特定于该应用。

2）、当需要存储这些数据结构时，可以采用通用数据模型（例如 JSON 或 XML 文档、关系数据库中的表或图模型）来表示。

3）、数据库工程师接着决定用何种内存、磁盘或网络的字节格式来表示上述 JSON/XML/关系/图形数据。数据表示需要支持多种方式的查询、搜索、操作和处理数据。

4）、在更下一层，硬件工程师则需要考虑用电流、光脉冲、磁场等来表示字节。

复杂的应用程序可能会有更多的中间层，例如基于 API 来构建上层 API，但是基本思想相同：每层都通过提供一个简洁的数据模型来隐藏下层的 **复杂性**。这些 **抽象** 机制使得不同的人群可以高效协作，例如数据厂商的工程师和使用数据库的应用程序开发人员一起合作。

### 1、关系模型

现在最著名的数据模型可能是 SQL，多年来在数据存储和查询方面主宰了市场。在 20 世纪 70 年代和 80 年代初期，网络模型和层次模型是两个主要的选择，但最终关系模型主宰了这个领域。对象数据库曾在 20 世纪 80 年代后期和 90 年代初期起起伏伏。XML 数据库则出现在 21 世纪初，但也仅限于利基市场。关系模型的每个竞争者都曾聒噪一时，可惜无一持久。

随着计算机变得越来越强大和网络化，服务目的日益多样化。值得注意的是，关系数据库超出了它们最初的商业数据处理范围，顺利推广到了各种各样的用例。当前在网络上看到的大部分内容，很多仍然是有关系数据库所支撑的，无论是在线发布、论坛、社交网络、电子商务、游戏、SAAS等。

层次模型与网络模型，在实际数据应用场景中，会异常复杂而没有灵活性。而相比之下，关系模型所做的则是定义了所有数据的格式：**关系（表）** 只是 **元组（行）** 的集合，仅此而已，不像层次模型与网络模型，没有复杂的嵌套结构，也没有复杂的访问路径。

在关系数据库中，**查询优化器** 自动决定以何种顺序执行查询，以及使用哪些 **索引**。实际上就是查询优化器自动生成了 “访问路径”。

**NoSQL**

NoSQL （不仅仅是SQL）成为推翻关系模式主导地位的又一个竞争者。采用 NoSQL 数据库有这样几个驱动因素，包括：

- 比关系数据库更好的 **扩展性** 需求，包括支持大数据集或超高写入吞吐量。
- 普遍偏爱 **免费和开源** 软件而不是商业数据库产品。
- 关系模型不能很好地支持一些 **特定的查询** 操作。
- 对关系模型一些限制性感到沮丧，渴望更具 **动态和表达力** 的数据模型。

### 2、文档模型

文档模型的数据结构例如 JSON、XML 或其二进制变体（如 MongoDB 的 BSON）。面向文档模型的数据库有：

- MongoDB
- RethinkDB
- CouchDB
- Espresso
- 等

**关系数据库** 与 **文档数据库** ：支持文档数据模型主要论点是模型灵活，由于局部性而带来较好的性能，对于某些应用来说，它更接近于应用程序所使用的的数据结构。关系模型则强在联结操作、多对一和多对多关系更加简洁的表达上，与文档模型抗衡。

当然，**融合** 关系模型与文档模型，是未来数据库发展的一条很好的途径。

> 数据查询语言

**A、命令式查询**

命令式语言告诉计算机以特定顺序执行某些操作。你完全可以推理整个过程，逐行遍历代码、评估相关条件、更新对应的变量，并决定是否在循环一遍。

**B、声明式查询**

而对于声明式查询语言（如 SQL 或关系代数），则只需要指定所需的数据模式，结果需满足什么条件，以及如何转换数据（例如，排序、分组和聚合），而不需要指明如何实现这一目标。数据库系统的 **查询优化器** 会决定采用哪些索引和联结，以及用何种顺序来执行查询的各个语句。

声明式查询语言很有吸引力，它比命令式 API 更加简洁和容易使用。但更重要的是，它对外 **隐蔽** 了数据库引擎的很多 **实现细节**，这样数据库系统能够在不改变查询语句的情况下提高性能。 

**C、MapReduce查询**

MapReduce 是一个相当底层的编程模型，用于在计算集群上分布执行。

MapReduce 既不是声明式查询语言，也不是一个完全命令式的查询 API，而是介于两者之间：查询的逻辑用代码片段来表示，这些代码片段可以被处理框架重复地调用。它主要基于许多函数式编程语言中的 map（也称为 collect）和 reduce（也称为 fold 或 inject ）函数。

### 3、图状数据模型

我们之前看到，多对多关系是不同数据模型之间的重要区分特征。如果数据大多是一对多关系（树结构数据）或记录之间没有关系，那么 **文档模型** 是最合适的。

但是，如果多对多的关系在数据中很常见呢？**关系模型** 能够吹了简单的多对多关系，但是随着数据之间的关系越来越复杂，将数据建模转化为 **图模型** 会更加自然。

图是由两种对象组成：

- 顶点（也称为结点或实体）
- 边（也称为关系或弧）

有很多不同但是相关的方法可以构建和查询复杂多对多数据。我们将主要讨论：

- 属性图模型（property graph，以 Neo4j、Titan 和 InfiniteGraph 为代表）
- 三元存储模型（triple-store，以 Datomic、AllegroGraph 等为代表）

**A、属性图**

在属性图模型中，每个顶点包括：

- 唯一的标识符
- 出边的集合
- 人边的集合
- 属性的集合（键-值对）

每个边包括：

- 唯一的标识符
- 边开始的顶点（尾部顶点）
- 边结束的顶点（头部顶点）
- 描述两个顶点间关系类型的标签
- 属性的集合（键-值对）

**Cypher查询语言**

Cypher 是一种用于属性图的声明式查询语言，最早为 Neo4j 图形数据库而创建。

**SQL中的图查询**

如果把图数据存储在关系结构中，通过 join 也能支持 SQL 查询，但是会随着关系增加而 SQL 变得越复杂。

**B、三元存储模型**

三元存储模式几乎等同于属性图模型，只是使用不同的名称描述相同的思想。在三元存储中，所有信息都以非常简单的三部分形成存储（主体，谓语，客体）。例如，在三元组（吉姆，喜欢，香蕉）中，吉姆是主体，喜欢为谓语（动词），香蕉是客体。

**RDF数据模型**

资源描述框架（Resource Description Framework），它让不同网站以一致的格式发布数据，这样来自不同网站的数据自动合并成一个数据网络，一种互联网级别包含所有数据的数据库。

**SPARQL查询语言**

SPARQL 是一种采用 RDF 数据模型的三元存储查询语言，名字是 SPARQL Protocol 和 RDF Query Language 的缩写，发音为“sparkle”。它比 Cypher 更早，并且由于 Cypher 的模式匹配是借用 SPARQL 的，所以二者看起来非常相似。

SPARQL 是一种非常优秀的查询语言，即使语义网从未实际出现，它也可以成为应用程序内部使用的强大查询工具。


**Datalog基础**

Datalog 是比 SPARQL 或 Cypher 更为古老的语言，在 20 世纪 90 年代被学者广泛研究。虽然在软件工程师中知名度较低，但它为以后的查询语言奠定了基础，因此它非常重要。实践中有几个数据库系统采用了 Datalog。例如它是 Datomic 系统的查询语言，而 Cascalog 是用于查询 Hadoop 大数据集的 Datalog 实现。

**注：Datomic 和 Cascalog 使用 Datalog 的Clojure S表达式语法。**

### 4、小结

**数据模型** 是一个庞大的主题，历史上数据最初被表示为一棵大树（层次模型），但是这不利于表示多对多，所以发明了关系模型来解决这个问题。最近，开发人员发现一些应用程序也不太适合关系模型。新的非关系 “NoSQL” 数据存储在两个主要方向上存在分歧：

1. 文档数据库的目标用例是数据来自于自包含文档，且一个文档与其他文档之间的关联很少。
2. 图数据库则针对相反的场景，目标用例是所有数据都可能会互相关联。

如今三种数据模型（文档模型、关系模型和图模型），都有广泛使用，并且在各自的目标领域都足够优秀。我们观察到，一个模型可以用另一个模型来模拟。例如图数据可以在关系数据库中表示，虽然处理起来比较笨拙。这就是为什么不同的系统用于不同的目的，而不是一个万能的解决方案。

文档数据库和图数据库有一个共同点，那就是他们通常不会对存储的数据强加某个模式，这可以使应用程序更容易适应不断变化的需求。但是，应用程序很可能仍然假定数据具有一定的结构，只不过是模式是显式（写时强制）还是隐式（读时处理）的问题。

每个数据模型都有自己的查询语言或框架，我们讨论了几个例子：

- SQL
- MapReduce
- MongoDB 的聚合管道
- Cypher
- SPARQL
- Datalog

另外还有 CSS 的 XSL/XPath，他们不属于数据库查询语言，但存在有趣的相似之处。

## 四、存储引擎与检索

从最基本的层面看，数据库只需要做两件事情：

- 向它插入数据时，他就保存数据；
- 之后查询时，它应该返回那些数据。

作为一名应用系统开发人员，为什么要关注数据库内部的 **存储** 和 **检索** 呢？首先，你不太可能从头开始实现一套自己的存储引擎，往往需要从众多现有的存储引擎中选择一个适合自己应用的存储引擎。因此，为了针对你特定的 **工作负载** 而对数据库 **调优** 时，最好对存储引擎的 **底层机制** 有一个大概的了解。

### 1、数据库核心：数据结构

最简单的数据结构像 CSV 文件，它底层的存储格式其实非常简单，就是一个纯文本文件。其中每行包含一个 **key-value** 对，用逗号分隔。每次 set 新值只需要追加新内容到文件末尾，因此，如果多次更新某个键，旧版本的值不会被覆盖，而是需要查看文件中最后一次出现的键来找到最新的值。

对于简单的情况，追加到文件末尾通常足够高效，而且能提现出良好性能，因此很多数据库内存都使用日志（log），日志是一个仅支持追加式更新的数据文件。虽然真正的数据库有很多更为复杂问题需要考虑，例如：并发控制、回收磁盘空间以控制日志文件大小、处理错误和部分完成写记录等，但是基本的原理是相同的。

但是，假如日志文件保存了大量的记录，那么 get 性能会非常差。每次想查找一个键，都必须从头到尾扫描整个数据库文件来查找键的出现位置。在算法术语中，查找的开销是 **O(n)**，即如果数据库的记录条数加倍，则查找需要两倍的时间。这一点特别不好。

为了高效地查找数据库中特定键的值，需要新的数据结构：**索引**。索引是基于原始数据派生而来的额外数据结构。很多数据库允许单独添加和删除索引，而不影响数据库的内容，它只会影响查询性能。维护额外的数据结构势必会引入开销，特别是在新数据写入时。对于写入，它很难超过简单地追加文件方式的性能，因为那已经是最简单的写操作了。由于每次写数据时，需要更新索引，因此任何类型的索引通常都会降低写的速度。

这里涉及存储系统中重要的权衡设计：**适当的索引可以加速读取查询，但每个索引都会减慢写速度**。为此，默认情况下，数据库通常不会对所有内容进行索引，它需要应用开发人员或数据库管理员，基于对应用程序典型查询模式的了解，来手动选择索引。目的是为应用程序提供最有利加速的同时，避免引入过多不必要的开销。

**A、哈希索引**

key-value 存储与大多数编程语言所内置的字典结构非常相似，通常采用 hash map （或 hash table，哈希表）来实现。

一个追加的日志乍看起来似乎很浪费空间：为什么不原地更新文件，用新值覆盖旧值？但是，结果证明追加式的设计非常不错，主要原因有以下几个：

- 追加和分段合并主要是顺序写，**顺序写** 通常比随机写入快得多，特别是在旋转式磁性硬盘上。在某种程度上，顺序写入在基于闪存的固态硬盘（solid state drives，SSD）上也是适合的。
- 如果段文件是追加的或不可变的，则 **并发** 和 **崩溃恢复** 要简单得多。例如，不必担心在重写值时发生崩溃的情况，留下一个包含部分旧值和部分新值混杂在一起的文件。
- 合并旧段可以避免随着时间的推移数据文件 **出现碎片化** 的问题。

但是，哈希表索引也有其 **局限性**：

- 哈希表必须全部 **放入内存**，所以如果有大量的键，就没那么幸运了。原则上，可以在磁盘上维护 hash map，但不幸的是，很难使磁盘上的 hash map 表现良好。它需要大量的随机访问 I/O，当哈希变满时，继续 **增长代价** 昂贵，并且 **哈希冲突** 时需要复杂的处理逻辑。
- 区间查询效率不高。例如，不能简单地支持扫描 kitty000000 和 kitty99999 区间内的所有键，只能采用逐个查找的方式查询每一个键。

维度 | 简单追加式日志 | 哈希索引日志
----|----------|-----
写性能| 顺序写，效率高，符合磁盘结构 | 计算哈希槽写入，少量开销，比顺序写慢
读性能| 扫描整个文件，查找的开销是 **O(n)** | 计算哈希槽读取，随机读性能高，区间查询效率不高（区间查将被拆分为逐个查） 
占用空间| 存储在磁盘，合并旧段可以避免随着时间的推移数据文件出现**碎片化**的问题 | 不浪费空间
存在问题| 读性能差，碎片化问题 | 哈希表必须全部放入内存，所以出现大量键时增长代价昂贵，并且哈希冲突时需要复杂的处理逻辑

**B、SSTables 和 LSM-Tree**

**C、B-trees**


**D、对比 B-tree 和 LSM-tree**

**E、其他索引结构**



### 2、事务处理与分析处理

**A、数据仓库**


**B、星型与雪花型分析模式**



### 3、列式存储

**A、列压缩**


**B、列存储中的排序**


**C、列存储的写操作**


**D、聚合：数据立方体与物化视图**


### 4、小结


