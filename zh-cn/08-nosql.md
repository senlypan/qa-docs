# 理解NoSQL

![访问统计](https://visitor-badge.glitch.me/badge?page_id=senlypan.qa.08-nosql&left_color=blue&right_color=red)

> 作者: 潘深练
>
> 创建: 2022-07-02

## 一、从数据模型出发

### 1、NoSQL诞生背景

- 语言的边界就是思想的边界。

数据模型可能是软件开发中最重要的部分了，因为它们的影响如此深远：不仅仅影响着软件的编写方式，而且影响着我们的解题思路

#### 1.1、关系模型

现在最著名的数据模型可能是SQL。它基于Edgar Codd在1970年提出的关系模型：数据被组织成关系（relations），在 SQL 中称为表（table），其中每个关系都是元组（tuples)的无序集合（在SQL中称为行）。

关系模型曾经只是一个理论性的提议，当时很多人都怀疑是否能够被高效地实现。然而，到了20世纪80年代中期，关系数据库管理系统（RDBMS）和 SQL 已成为大多数人们存储、查询具有某种规则结构数据的首选工具。关系数据库的主导地位已经持续了25~30年，这在计算机历史称得上一段不朽传奇。

关系数据库起源于 **商业数据处理**，20世纪60年代和70年代主要运行在大型计算机之上。从今天的角度来看，用例看起来很常见，主要是 **事务处理**（包括输入销售和银行交易、航空公司订票、仓库库存）和 **批处理**（例如客户发票、工资单、报告）。

当时的其他数据库迫使应用程序开发人员必须考虑数据库内部的数据表示形式。关系模型的目标就是致力于将上述实现细节隐藏在更简洁的接口之上。

#### 1.2、网络模型和分层模型

多年来，在 **数据存储** 和 **查询** 方面存在着许多相互竞争的技术。在20世纪70年代和80年代初期，**网络模型** 和 **分层模型** 曾是两个主要的选择，但最终 **关系模型** 主宰了这个领域。**对象数据库** 曾在20世纪80年代后期和90年代初期起起伏伏。**XML数据库** 则出现在21世纪初，但也仅限于利基市场。关系模型的每个竞争者都曾名噪一时，可惜无一持久。

随着计算机变得越来越强大和网络化，服务目的日益多样化。值得注意的是，关系数据库超出了它们最初的商业数据处理范围，顺利推广到了各种各样的用例。当前在网络上看到的大部分内容很多仍然是由关系数据库所支撑的，无论是在线发布、论坛、社交网络、电子商务、游戏、SaaS等。

#### 1.3、NoSQL

进入21世纪，NoSQL称为推翻 **关系模型** 主导地位的又一个竞争者。“NoSQL” 这个名字是不恰当的，因为它其实并不代表具体的某些技术，它最初知识作为一个吸引人眼球的 Twitter 标签频繁出现在 2009 年的开源、分布式以及非关系数据库的见面会上。尽管如此，这个称呼还是让人有所触动，并迅速传遍了网络创业社区。现在很多新兴的数据库系统总是会打上 NoSQL 的标签，而其含义也已经被逆向重新解释为“ Not Only SQL”。

|出场顺序| 数据模型 |
|-----|-----|
|1|网络模型、层次模型|
|2|关系模型|
|3|文档模型（XML、JSON、对象）|
|4|图状数据模型|

#### 1.4、小结

**数据模型** 是一个巨大的课题。在历史上，数据最开始被表示为一棵大树（层次数据模型），但是这不利于表示多对多的关系，所以发明了关系模型来解决这个问题。最近，开发人员发现一些应用程序也不适合采用关系模型。新的非关系型“NoSQL”数据存储在两个主要方向上存在分歧：

- 1、**文档数据库** 的应用场景是：数据通常是自我包含的，而且文档之间的关系非常稀少。
- 2、**图形数据库** 用于相反的场景：任意事物都可能与任何事物相关联。

这三种模型（文档，关系和图形）在今天都被广泛使用，并且在各自的领域都发挥很好。一个模型可以用另一个模型来模拟 — 例如，图数据可以在关系数据库中表示 — 但结果往往是糟糕的。这就是为什么我们有着针对不同目的的不同系统，而不是一个单一的万能解决方案。

文档数据库和图数据库有一个共同点，那就是它们通常不会为存储的数据强制一个模式，这可以使应用程序更容易适应不断变化的需求。但是应用程序很可能仍会假定数据具有一定的结构；这只是模式是明确的（写入时强制）还是隐含的（读取时处理）的问题。

每个数据模型都具有各自的查询语言或框架，我们讨论了几个例子：SQL，MapReduce，MongoDB的聚合管道，Cypher，SPARQL和Datalog。我们也谈到了CSS和XSL/XPath，它们不是数据库查询语言，而包含有趣的相似之处。

虽然我们已经覆盖了很多层面，但仍然有许多数据模型没有提到。举几个简单的例子：

- 使用基因组数据的研究人员通常需要执行序列相似性搜索，这意味着需要一个很长的字符串（代表一个DNA分子），并在一个拥有类似但不完全相同的字符串的大型数据库中寻找匹配。这里所描述的数据库都不能处理这种用法，这就是为什么研究人员编写了像GenBank这样的专门的基因组数据库软件的原因。
- 粒子物理学家数十年来一直在进行大数据类型的大规模数据分析，像大型强子对撞机（LHC）这样的项目现在可以工作在数百亿兆字节的范围内！在这样的规模下，需要定制解决方案来阻住硬件成本的失控。
- 全文搜索可以说是一种经常与数据库一起使用的数据模型。信息检索是一个很大的专业课题。

### 2、NoSQL能做什么

采用 NoSQL 数据库有这样几个驱动因素，包括：

- 比关系数据库更好的 **扩展性需求**，包括支持超大数据集或超高写入吞吐量。
- 普遍偏爱 **免费** 和 **开源软件** 而不是商业数据库昌平。
- 关系模型不能很好地支持 **特定的查询操作**。
- 对关系模式一些限制性感到沮丧，渴望更具 **动态和表达力** 的数据模型。 

不同的应用程序有不同的需求，某个用例的最佳的技术选择未必适合另一个用例。因此，在可预见的未来，关系数据库可能仍将继续与各种非关系数据存储一起使用，这种思路有时也被称为 **混合持久化**。

### 3、NoSQL vs RDBMS

| 比较 | RDBMS | NoSQL |  
| ---- | ------------ | ------------ |  
| 场景 | 强一致性，严格事务 | 最终一致性，低延迟 |  
| 模型 | 表，行，列，索引| 键值对，文档，图，列存储 |  
| 理论基础 | ACID | CAP，BASE |  
| 事务 | 支持 | 不支持 |   
| 模式 | 预定义的模式 | 没有预定义的模式 |   
| 查询语言 | 结构化查询语言（SQL） | 没有声明式查询语言 |  
| 数据 | 高度组织化结构化数据 | 非结构化和不可预知的数据 | 
| 拓展 | 垂直扩展（纵向） | 水平扩展（分布式） |  

> RDBMS 的 sharding 分片，replica 算是水平扩展，而其中关系数据库 polardb 也支持水平扩展。所以关系数据库的事务与关系严格限制，所以在水平拓展性上，实现的难度高、成本大。

### 4、NoSQL数据库分类

|分类|主流产品|典型应用场景|数据模型|优势|不足|
|----|----|----|----|----|----|
|键值（key-value）| Tokyo Cabinet/Tyrant, Redis, Voldemort, OracleBDB|内存缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等|Key 指向 Value 的键值对，通常用 Hash Table 来实现| 查询速度快 | 数据无结构化，通常只被当做字符串或者二进制数据|
|列存储数据库| Cassandra, HBase, Riak| 分布式的文件系统 | 以列簇存储，将同一列数据存在一起|查找速度快，可扩展性强，更容易进行分布式扩展|功能/类型相对局限|
|文档型数据库|CouchDB, MongoDB, SequoiaDB| Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解 value 的内容）|Key-Value对应的键值对，Value为结构化数据|数据结构要求不严格，表结构可变，不需要像关系型数据库一样预先定义表结构|查询性能不高，而且缺乏统一的查询语法|
|图形（Graph）数据库|Neo4J, InfoGrid, Infinite Graph| 社交网络，推荐系统等。专注于构建关系图谱|图结构|利用图结构相关算法。比如最短路径寻址，N度关系查找等|很多时候需要对整个图做计算得出需要的信息，而且这种结构不太好做分布式的集群方案。|

- [CNCF-Cloud Native Computing Foundation(云原生计算基金会)](https://landscape.cncf.io/)

## 二、数据存储与检索

### 1、日志结构与原地更新

> 数据库的核心是数据结构

#### 1.1 引擎演进

目前主流的数据库存储引擎主要有两大阵营：

- B+Tree
    - Balance Tree，平衡搜索树的一种
    - 应用为传统数据库引擎，例如 MySQL 的 InnoDB
- LSM-Tree
    - Log-Structured MergeTree ，日志结构合并树
    - 应用为新生代（或说NoSQL）数据库引擎，例如 HBase，Cassandra

一般数据库引擎为了 **查询性能最优**，数据需要按照 **顺序排列**，当然也追求高效的写。

**B+Tree的特点与不足**

B+Tree 不同于红黑树，红黑树是假设所有节点都在内存中，而 B+Tree 是为了磁盘搜索而诞生的，B+Tree 的所有数据都存储在叶子节点中，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针（**带顺序访问指针**，提高区间效率），在每次写入或查询时，需要从根节点搜索到叶子节点，再对叶子节点的对应位置进行操作，同时传统的数据库引擎会将 B+Tree 的每个叶子节点设置为一个磁盘页的大小，巧妙利用了磁盘预读原理，将一个叶子节点的大小设为等于一个页，这样每个叶子节点需要一次 I/O 就可以完全载入，**大大减少磁盘 I/O 读取**。

但是 B+Tree 的查询/插入/删除时间复杂度都是 O(log2^n)，在这种随机读写的场景下，磁盘的寻址定位的时间还是太长了，不能发挥出磁盘的最佳性能。

**LSM-Tree的特点**

磁盘随机 I/O 和顺序 I/O 的性能差距甚大，而 LSM-Tree 的核心思想就是 **将离散的随机写请求都转化成批量的顺序写请求**。相对于 B+Tree 每次插入都是 O(log2^n) 更新到磁盘，LSM-Tree 采取的方案（举例蚂蚁的 OceanBase 存储引擎）是：

- 当用户有数据写入时，会写入内存中的 Memtable。
- 当写入的 Memtable 的数据量达到阈值时，会将 Memtable 冻结为只读的 Frozen Memtable，同时创建出一个新的 Memtable，用于提供数据写入，系统会将所有的 Frozen Memtable 数据写入磁盘，生成一个内部有序的 SSTable
- 但是查询时，需要查找几乎所有的 SSTable，查询的时间复杂度与 SSTable 的数量呈正相关性
- 为了解决 SSTable 数量过多的问题，业界通常采用 Leveled Compaction 的策略：将 SSTable 进行分层管理，当每层的 SSTable 数量超过阈值时，会触发一次 Compaction，Compaction 的实质就是将多个 SSTable 的数据进行归并排序，最后输出到同一个 SSTable，在 Compaction 后 SSTable 还可以控制在一个合理范围，并且可以通过 BloomFilter 等机制进行查询的加速。

#### 1.2 关系梳理


- 原地更新
    - BTree
    - B-Tree
    - B+Tree
    - B*Tree
    - 详见[《二、数据结构/3.1、BTree,B-Tree,B+Tree,B*Tree的数据结构》](/zh-cn/03-data-structure?id=_31%e3%80%81btreeb-treebtreebtree%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84)
- 日志结构 
    - 日志追加
    - Hash索引
    - LSM-Tree
        - 机制
            - Memtable（内存表，在内存中维护一个有序的列表）
                - AVL树
                    - 在计算机科学中，AVL 树（以发明者 **A**delson-**V**elsky 和 **​​L**andis 命名）是一种自平衡二叉搜索树(BST)。这是发明的第一个这样的数据结构。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为**高度平衡树**。如果在任何时候它们的差异超过一个，则会进行**重新平衡**以恢复此属性。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。在平均情况和最坏情况下，查找、插入和删除都需要O(logn)时间，其中n是操作前树中的节点数。插入和删除可能需要通过一个或多个树**旋转**来重新平衡树。
                    - AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis，他们在1962年的论文《An algorithm for the organization of information》中发表了它。
                - 红黑树
                - 跳表
            - SSTable（有序的磁盘文件）
        - 实现
            - LevelDB
                - Lucene
            - RocksDB

- 待办
    - 2、存储与索引再重新梳理
    - 3、Bitcask 归类
    - 4、LSM-tree 实现机制中 SSTable 的几种 Compaction 方案添加到上述 LSM-Tree 特点中
    - 5、阅读[《mysql底层原理-二叉树、红黑树、BTree、B+Tree》](https://www.youtube.com/watch?v=2iqa7uAm-qE) 并梳理进本文



### 2、OLTP vs OLAP 

| 属性 | 事务处理系统（OLTP） | 分析系统（OLAP） |
|----|----|----|
|主要读取模式 |	查询少量记录，按键读取 |	在大批量记录上聚合 |
|主要写入模式 |	随机访问，写入要求低延时 |	批量导入（ETL），事件流 |
|主要用户 |	终端用户，通过Web应用 |	内部数据分析师，决策支持 |
|处理的数据 |	数据的最新状态（当前时间点） |	随时间推移的历史事件 |
|数据集尺寸 |	GB ~ TB |	TB ~ PB |

#### 2.1、OLTP

#### 2.2、OLAP

- 数据仓库
    - ETL
    - 星型与雪花型分析模式
- 列式存储
    - 列压缩
        - 面向列的存储和列族
        - 内存带宽和向量处理
    - 列存储中的排序顺序
        - 几个不同的排序顺序
    - 写入列存储
    - 聚合：数据立方体与物化视图

#### 2.3、小结

在高层次上，我们看到存储引擎分为两大类：优化 **事务处理（OLTP）** 或 **在线分析（OLAP）** 。这些用例的访问模式之间有很大的区别：

- OLTP系统通常面向用户，这意味着系统可能会收到大量的请求。为了处理负载，应用程序通常只访问每个查询中的少部分记录。应用程序使用某种键来请求记录，存储引擎使用索引来查找所请求的键的数据。磁盘寻道时间往往是这里的瓶颈。

- 数据仓库和类似的分析系统会低调一些，因为它们主要由业务分析人员使用，而不是由最终用户使用。它们的查询量要比OLTP系统少得多，但通常每个查询开销高昂，需要在短时间内扫描数百万条记录。磁盘带宽（而不是查找时间）往往是瓶颈，列式存储是这种工作负载越来越流行的解决方案。

在OLTP方面，我们能看到两派主流的存储引擎：

- **日志结构学派**

只允许附加到文件和删除过时的文件，但不会更新已经写入的文件。 Bitcask，SSTables，LSM树，LevelDB，Cassandra，HBase，Lucene等都属于这个类别。

- **就地更新学派**

将磁盘视为一组可以覆写的固定大小的页面。 B树是这种哲学的典范，用在所有主要的关系数据库中和许多非关系型数据库。

日志结构的存储引擎是相对较新的发展。他们的主要想法是，他们系统地将随机访问写入顺序写入磁盘，由于硬盘驱动器和固态硬盘的性能特点，可以实现更高的写入吞吐量。在完成OLTP方面，我们通过一些更复杂的索引结构和为保留所有数据而优化的数据库做了一个简短的介绍。

然后，我们从存储引擎的内部绕开，看看典型数据仓库的高级架构。这一背景说明了为什么分析工作负载与OLTP差别很大：当您的查询需要在大量行中顺序扫描时，索引的相关性就会降低很多。相反，非常紧凑地编码数据变得非常重要，以最大限度地减少查询需要从磁盘读取的数据量。我们讨论了列式存储如何帮助实现这一目标。

作为应用开发人员，掌握更多有关存储引擎内部得知识，可以更好地了解哪种工具最适合你的具体应用。如果还需要进一步调整数据库的可调参数，这些理解还可以帮助开发者正确评估调高或调低参数所带来的影响。

## 三、参考文献

- [YouTube -《GettingStarted - NoSQL - MongoDB》](https://www.youtube.com/watch?v=5rbFoSGHErA&list=PLf0swTFhTI8ra5T5B7QsNuu5yxiEdd6Ro)

- [YouTube -《Cassandra-NoSQL-Tutorials》](https://www.youtube.com/watch?v=8G4a4G3S654&list=PLpE_8MUgZj5vSp1Q_5GyDKBgy9dG1ifdE)

- [YouTube -《Redis ServerTutorial》](https://www.youtube.com/watch?v=fyV3OK1fCr0&list=PLpIXNzrq3JHQ8-QCJqrC2ihrGJkjdN2J6)

- [Wechat -《一文读懂非关系型数据库（NoSQL》](https://mp.weixin.qq.com/s/xwxK0gMSn79amYL3km_f7g)

- [bookstack -《数据模型与查询语言》](https://www.bookstack.cn/read/ddia/ch2.md)

- [bookstack -《存储与检索》](https://www.bookstack.cn/read/ddia/ch3.md)
